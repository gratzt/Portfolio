<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Using machine learning and optimization for resource planning: a case study in locating opioid use disorder treatment units â€“ Trevor Gratz</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-dfb324f25d9b1687192fa8be62ac8f9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Trevor Gratz</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Resume.html"> 
<span class="menu-text">Trevor Gratz</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a>
  <ul class="collapse">
  <li><a href="#key-findings" id="toc-key-findings" class="nav-link" data-scroll-target="#key-findings">Key Findings</a></li>
  <li><a href="#data-sources" id="toc-data-sources" class="nav-link" data-scroll-target="#data-sources">Data Sources</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#building-the-application-for-data-informed-decision-making" id="toc-building-the-application-for-data-informed-decision-making" class="nav-link" data-scroll-target="#building-the-application-for-data-informed-decision-making">Building the application for data-informed decision making</a></li>
  <li><a href="#site-selection-and-power-analysis-for-block-randomized-trials-a-problem-of-search" id="toc-site-selection-and-power-analysis-for-block-randomized-trials-a-problem-of-search" class="nav-link" data-scroll-target="#site-selection-and-power-analysis-for-block-randomized-trials-a-problem-of-search">Site Selection and Power Analysis for Block-Randomized Trials: A Problem of Search</a></li>
  </ul></li>
  <li><a href="#next-steps" id="toc-next-steps" class="nav-link" data-scroll-target="#next-steps">Next Steps</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Using machine learning and optimization for resource planning: a case study in locating opioid use disorder treatment units</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level1">
<h1>Overview</h1>
<p>Opioid use disorder has been widely viewed as a growing public health emergency. Medication-assisted therapy (MAT) is considered the gold standard for treating opioid use-disorder: MAT can reduce overdose mortality by up to three fold. However, facilities that serve residents are often in urban settings, and MAT can be difficult to access outside of major metropolitan areas. Pierce County is addressing the needs of rural residents by provisioning mobile opioid use disorder treatment vans.</p>
<p>The analyses and tools presented here support the planning phase of rolling out a mobile opioid use disorder van. It also supported the design process of a randomized controlled trial (RCT) of the effectiveness of mobile opioid use disorder vans on reducing substance abuse. Pierce County partnered with UC Santa Cruz to plan the RCT.</p>
<p>This application plots potential site locations for mobile opioid use disorder treatment vans, their location relative to the number of overdose 911-related calls, and their locations relative to main roads and transit. Potential sites have been clustered into high, medium, and low needs areas based on overdose call locations and accessibility.</p>
<p>If the applicaiton is asleep it is best to wake it from its <a href="https://odlocationcalls-fhv9mbksbcgsyjullanean.streamlit.app/?embed=true#middle-section">homepage</a>.</p>
<iframe src="https://odlocationcalls-fhv9mbksbcgsyjullanean.streamlit.app/?embed=true#middle-section" height="600" width="100%" style="border:none;" sandbox="allow-same-origin allow-scripts allow-forms">
</iframe>
<section id="key-findings" class="level2">
<h2 class="anchored" data-anchor-id="key-findings">Key Findings</h2>
<ul>
<li>Cluster analysis revealed three kinds of potential sites: high call volume and high accessibility, medium call volume and medium accessibility, and low call volume and low accessibility. The site characteristics by cluster are depicted in Table 1 below.</li>
</ul>
<p><br></p>
<p><strong>Table 1. Site Mean and Standard Deviation by Cluster</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 23%">
<col style="width: 23%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Cluster 1 (Low)</th>
<th>Cluster 2 (Medium)</th>
<th>Cluster 3 (High)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Calls within 500 meters</td>
<td>0.2 (0.4)</td>
<td>1.1 (1.3)</td>
<td>3.4 (1.1)</td>
</tr>
<tr class="even">
<td>Calls within 1,000 meters</td>
<td>0.6 (1.0)</td>
<td>3.9 (2.9)</td>
<td>17 (11.2)</td>
</tr>
<tr class="odd">
<td>Calls within 2,000 meters</td>
<td>1.6 (2.8)</td>
<td>9.5 (5.9)</td>
<td>40.4 (9.3)</td>
</tr>
<tr class="even">
<td>Calls within 3,000 meters</td>
<td>3.0 (4.6)</td>
<td>17.1 (14.5)</td>
<td>61.6 (14.0)</td>
</tr>
<tr class="odd">
<td>Meters to transit</td>
<td>16,389 (17,925)</td>
<td>1,258 (1,975)</td>
<td>239 (224)</td>
</tr>
<tr class="even">
<td>Meters to closest major road</td>
<td>1,269 (1,747)</td>
<td>481 (626)</td>
<td>184 (100)</td>
</tr>
</tbody>
</table>
<p><br></p>
<ul>
<li>Outside of Tacoma, overdose calls and accessibility were highest along the Highway 7 and WA Route 161 corridors. This is evidenced from the calls data themselves, but also the categorization of potential sites along these corridors into cluster 3.</li>
</ul>
</section>
<section id="data-sources" class="level2">
<h2 class="anchored" data-anchor-id="data-sources">Data Sources</h2>
<ul>
<li>2023 South Sound 911 Overdose Calls</li>
<li>Pierce County data on:
<ul>
<li>Fire stations</li>
<li>Libraries</li>
<li>Safe Parking sites</li>
<li>Roads</li>
<li>Bus stops</li>
</ul></li>
<li>Fixed MAT Locations</li>
</ul>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="building-the-application-for-data-informed-decision-making" class="level3">
<h3 class="anchored" data-anchor-id="building-the-application-for-data-informed-decision-making">Building the application for data-informed decision making</h3>
<p>Subject matter experts at Pierce County Human Services identified fire stations, libraries, and safe parking sites as potential partners for locating a mobile opioid use-disorder van on the premises. For each potential site i, the number of calls was calculated within 500, 1000, 2000, and 3000 meters. Because we want to prioritize potential sites with ease of access, I also calculated the distance to the closest bus stop and major road. I omitted sites in the City of Tacoma due to itâ€™s high presence of fixed MAT location and greater access to services.</p>
<p>After performing standard scalar feature normalization, K-means clustering was applied on the feature set. K-means applies equal weighting to all features. However, from the context it is clear that the proximity of overdose calls to potential sites is more relevant than access to the site alone. The multiple features for the number of calls within different specified radii of the site increase the relative importance of the number of calls nearby, as well as capture information from different ranges of distance to sites.</p>
<p>The site information, datasets, and clustering algorithm were packaged and ported into the Streamlit application. This allows the user to explore potential sites other than the pre-calculated sites at fire stations, libraries and safe parking.</p>
<p>This application alone was sufficient to help Pierce County Human Servicesâ€™ program managers think through the implications of different site locations. However, it is unable to help researchers think through the implications of site selection on statistical power.</p>
</section>
<section id="site-selection-and-power-analysis-for-block-randomized-trials-a-problem-of-search" class="level3">
<h3 class="anchored" data-anchor-id="site-selection-and-power-analysis-for-block-randomized-trials-a-problem-of-search">Site Selection and Power Analysis for Block-Randomized Trials: A Problem of Search</h3>
<p>This methodology outlines a systematic approach to selecting experimental sites for a block-randomized trial in order to maximize statistical power while minimizing the risk of treatment spillover between sites. The statistical framework is based on the model of one treated unit per block with potentially multiple control units, following the approach of Pashley and Miratrix (2021). Power is calculated using pre-treatment outcome data to estimate within-block variances, and is directly linked to minimizing the variance of the treatment effect estimator. Key assumptions include homoskedasticity within blocks, independence between treatment and control units, and block-level heterogeneity in variance.</p>
<p>To operationalize site selection, a three-stage approach is developed. First, the method uses integer programming to select the largest possible number of sites that satisfy a minimum distance constraint, preventing spillover. Second, k-means clustering is applied to group selected sites into blocks with similar pre-treatment outcome values, minimizing within-block variance. Finally, statistical power is calculated based on this block structure using standard power formulas. This approach balances competing design goals: maximizing sample size, ensuring spatial independence, and minimizing outcome variance, ultimately yielding a more efficient and robust trial design.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Technical Details: Statistical Framework and Implementation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">1. Introduction</h3>
<p>This document outlines the methodology used to select sites so as to maximize statistical power. This report discusses the statistical model used in a block-randomized trial with exactly one treated unit per block and potentially multiple control units, where block sizes may be unbalanced. The approach leverages pre-treatment data to estimate variance components and follows the framework established by Pashley and Miratrix (2021) for calculating power. It discusses the potential of spillover effects in a spatial randomization and develops a methodology to maximize statistical power while minimizing the potential for spillover.</p>
</section>
<section id="statistical-model" class="level3">
<h3 class="anchored" data-anchor-id="statistical-model">2. Statistical Model</h3>
<p>The basic model for a block-randomized trial can be expressed as:</p>
<p><span class="math display">\[Y_{ik} = \alpha_k + \tau Z_{ik} + \varepsilon_{ik}\]</span></p>
<p>Where: - <span class="math inline">\(Y_{ik}\)</span> is the outcome for unit <span class="math inline">\(i\)</span> in block <span class="math inline">\(k\)</span> - <span class="math inline">\(\alpha_k\)</span> is the block-specific fixed effect - <span class="math inline">\(\tau\)</span> is the treatment effect (our parameter of interest) - <span class="math inline">\(Z_{ik}\)</span> is the treatment indicator (1 for treatment, 0 for control) - <span class="math inline">\(\varepsilon_{ik}\)</span> is the random error term</p>
</section>
<section id="estimation-of-treatment-effect" class="level3">
<h3 class="anchored" data-anchor-id="estimation-of-treatment-effect">3. Estimation of Treatment Effect</h3>
<p>Following Pashley and Miratrix (2021), the blocked estimator of the average treatment effect is:</p>
<p><span class="math display">\[\hat{\tau}_{(BK)} = \sum_{k=1}^{K} \frac{n_k}{n} \hat{\tau}_k\]</span></p>
<p>Where: - <span class="math inline">\(K\)</span> is the total number of blocks - <span class="math inline">\(n_k\)</span> is the number of units in block <span class="math inline">\(k\)</span> (including both treated and control) - <span class="math inline">\(n = \sum_{k=1}^{K} n_k\)</span> is the total sample size - <span class="math inline">\(\hat{\tau}_k\)</span> is the estimated treatment effect within block <span class="math inline">\(k\)</span></p>
<p>For our design with exactly one treated unit per block, <span class="math inline">\(\hat{\tau}_k\)</span> is:</p>
<p><span class="math display">\[\hat{\tau}_k = Y_k^T - \bar{Y}_k^C\]</span></p>
<p>Where <span class="math inline">\(Y_k^T\)</span> is the outcome for the treated unit in block <span class="math inline">\(k\)</span> and <span class="math inline">\(\bar{Y}_k^C\)</span> is the mean outcome for the control units in block <span class="math inline">\(k\)</span>.</p>
</section>
<section id="variance-of-the-treatment-effect-estimator" class="level3">
<h3 class="anchored" data-anchor-id="variance-of-the-treatment-effect-estimator">4. Variance of the Treatment Effect Estimator</h3>
<p><a href="https://journals.sagepub.com/doi/full/10.3102/1076998620946272">Pashley and Miratrix</a> (2021) provide the variance formula for the blocked estimator in their Equation (2). Adapting this for our specific case with one treated unit per block and assuming independence between treatment and control units within blocks:</p>
<p><span class="math display">\[Var(\hat{\tau}_{(BK)}) = \sum_{k=1}^{K} \left(\frac{n_k}{n}\right)^2 Var(\hat{\tau}_k)\]</span></p>
<p>Within each block, the variance of the block-specific treatment effect is:</p>
<p><span class="math display">\[Var(\hat{\tau}_k) = Var(Y_k^T) + Var(\bar{Y}_k^C) = \sigma_k^2 + \frac{\sigma_k^2}{n_k^C}\]</span></p>
<p>Where: - <span class="math inline">\(\sigma_k^2\)</span> is the variance of outcomes within block <span class="math inline">\(k\)</span> - <span class="math inline">\(n_k^C = n_k - 1\)</span> is the number of control units in block <span class="math inline">\(k\)</span></p>
<p>Simplifying:</p>
<p><span class="math display">\[Var(\hat{\tau}_k) = \sigma_k^2\left(1 + \frac{1}{n_k^C}\right) = \sigma_k^2\left(\frac{n_k^C + 1}{n_k^C}\right) = \sigma_k^2\left(\frac{n_k}{n_k - 1}\right)\]</span></p>
<p>Therefore, the variance of our treatment effect estimator is:</p>
<p><span class="math display">\[Var(\hat{\tau}_{(BK)}) = \sum_{k=1}^{K} \left(\frac{n_k}{n}\right)^2 \sigma_k^2\left(\frac{n_k}{n_k - 1}\right) = \sum_{k=1}^{K} \frac{n_k^3}{n^2(n_k - 1)}\sigma_k^2\]</span></p>
<p>For this analysis, we make the following assumptions:</p>
<ol type="1">
<li><p><strong>Homoskedasticity within blocks</strong>: The variance of outcomes is constant within each block (i.e., treated and control units have the same variance within a block). This assumption is necessary as we have no pre-treatment data on treated outcomes with which to estimate the variance.</p></li>
<li><p><strong>Independence</strong>: Treatment and control outcomes are independent within blocks, conditional on block membership.</p></li>
<li><p><strong>Block-specific heterogeneity</strong>: The variance can differ across blocks (i.e., <span class="math inline">\(\sigma_k^2\)</span> can vary with <span class="math inline">\(k\)</span>).</p></li>
<li><p><strong>Treatment affects means only</strong>: The treatment affects the mean of the outcome but not its variance.</p></li>
<li><p><strong>Pre-treatment data is sufficient to estimate outcome variance post-treatment</strong>: The estimation of statistical power, as shown in in section 6, relies on an accurate estimation of the variance of our treatment effect.</p></li>
</ol>
</section>
<section id="estimation-of-variance-components-from-pre-treatment-data" class="level3">
<h3 class="anchored" data-anchor-id="estimation-of-variance-components-from-pre-treatment-data">5. Estimation of Variance Components from Pre-treatment Data</h3>
<p>We can leverage pre-treatment outcome data to estimate the variance components required for power analysis:</p>
<p><span class="math display">\[\hat{\sigma}_k^2 = \frac{1}{n_k-1} \sum_{i=1}^{n_k} (Y_{ik,pre} - \bar{Y}_{k,pre})^2\]</span></p>
<p>Where: - <span class="math inline">\(Y_{ik,pre}\)</span> is the pre-treatment outcome for unit <span class="math inline">\(i\)</span> in block <span class="math inline">\(k\)</span> - <span class="math inline">\(\bar{Y}_{k,pre}\)</span> is the mean pre-treatment outcome in block <span class="math inline">\(k\)</span></p>
<p>These estimates can then be substituted into the variance formula:</p>
<p><span class="math display">\[\widehat{Var}(\hat{\tau}_{(BK)}) = \sum_{k=1}^{K} \frac{n_k^3}{n^2(n_k - 1)}\hat{\sigma}_k^2\]</span></p>
</section>
<section id="power-calculation" class="level3">
<h3 class="anchored" data-anchor-id="power-calculation">6. Power Calculation</h3>
<p>For a given significance level <span class="math inline">\(\alpha\)</span> (typically 0.05) and a minimum detectable effect size <span class="math inline">\(\delta\)</span>, the <a href="https://chabefer.github.io/STCI/Power.html#basics-of-traditional-power-analysis-using-test-statistics">power</a> of the test is:</p>
<p><span class="math display">\[Power = 1 - \beta = \Phi\left(\frac{|\delta|}{\sqrt{\widehat{Var}(\hat{\tau}_{(BK)})}} - z_{1-\alpha/2}\right)\]</span></p>
<p>Where: - <span class="math inline">\(\Phi\)</span> is the cumulative distribution function of the standard normal distribution - <span class="math inline">\(z_{1-\alpha/2}\)</span> is the critical value (e.g., 1.96 for <span class="math inline">\(\alpha = 0.05\)</span> with a two-sided test)</p>
<p>Alternatively, to determine the required sample size for a desired power level <span class="math inline">\(1-\beta\)</span>, we need to solve:</p>
<p><span class="math display">\[\frac{|\delta|}{\sqrt{\widehat{Var}(\hat{\tau}_{(BK)})}} - z_{1-\alpha/2} = z_{1-\beta}\]</span></p>
<p>Which gives:</p>
<p><span class="math display">\[\widehat{Var}(\hat{\tau}_{(BK)}) = \frac{\delta^2}{(z_{1-\alpha/2} + z_{1-\beta})^2}\]</span></p>
<p>We can then determine how many blocks or how many units per block would be needed to achieve this target variance.</p>
</section>
<section id="optimizing-power-and-preventing-spill-over" class="level3">
<h3 class="anchored" data-anchor-id="optimizing-power-and-preventing-spill-over">7. Optimizing Power and Preventing Spill Over</h3>
<p>Our goal is to select sites to maximize statisticl power, while ensuring there is no spill over of treatment effects between sites. We can minimize the potential of spill over effects by ensuring all selected sites are at a minimum of X meters away from each other. The optimization program is formed as follows:</p>
<p>Let: - <span class="math inline">\(S_{i,k}\)</span> be a 0/1 indicator for whether site <span class="math inline">\(i\)</span> is in block <span class="math inline">\(k\)</span> - <span class="math inline">\((L_{i,1}, L_{i, 2})\)</span> be the coordinates of site <span class="math inline">\(i\)</span> in a projection (EPSG:6559) such that the euclidian distance between two coordinates is meters - <span class="math inline">\(D_{min}\)</span> be the minimum distance two sites must be apart for spill over to be neglegble</p>
<p>The objective function is:</p>
<p><span class="math display">\[ argmax_{S_{i,g}} \Phi\left(\frac{|\delta|}{\sqrt{\widehat{Var}(\hat{\tau}_{(BK)})}} - z_{1-\alpha/2}\right)\]</span></p>
<p>Subject to:</p>
<p><span class="math display">\[ \sum_{g} S_{i,g} \leq 1 \quad \forall i \]</span></p>
<p><span class="math display">\[\sqrt{(L_{i,1}-L_{j,1})^2 + (L_{i,2}-L_{j,2})^2} \geq (\sum_{g} S_{i,g})(\sum_{g} S_{j,g})D_{min} \quad \forall i, j \quad if \: i\neq j   \]</span></p>
<p>Here the first constraint ensures each site can belong to only one block at most. The second constraint requires selected sites only to be at least <span class="math inline">\(D_{min}\)</span> meters away from each other.</p>
<p>This optimiztion problem is constrained, highly non-linear, and is a mixed binary and continuous problem. It is not tractable with existing methods. However, examining the factors that influence the power calculation can yield insight into how to design an approach that may approximate site selection for maximal power. Specifically, power is maximized when the variance of the treatment effect estimator is minimized. Examining the formula for the treatment effect variance shows that it is minimized when sample sizes increase and when the within-block variances are minimized. Unfortunately, increasing sample sizes and minimizing within-block variance may not always be compatible. In section 9 below we detail an approach that weighs the tradeoffs between maximizing sample size and minimizing within-block variance while ensuring negligible spillover.</p>
</section>
<section id="three-stage-approach-to-maximizing-power" class="level3">
<h3 class="anchored" data-anchor-id="three-stage-approach-to-maximizing-power">8. Three Stage Approach to Maximizing Power</h3>
<p>Our approach to maximizing power while preventing spillover effects combines three stages:</p>
<section id="stage-1-maximize-site-selection-with-minimum-distance-constraints" class="level4">
<h4 class="anchored" data-anchor-id="stage-1-maximize-site-selection-with-minimum-distance-constraints">Stage 1: Maximize Site Selection with Minimum Distance Constraints</h4>
<p>In the first stage, we select the maximum number of sites that satisfy the distance constraint to prevent spillover effects while also filter to sites within pre-specified ranges of the outcome variable of interest. For example, we filter to all sites with more than 10 calls within 3,000 meters in a year. This filtering is aimed at reducing within-block variance prior to site selection, as the site selection process itself is ignorant of within-block variance. After prefiltering, we solve for the maximum number of sites.</p>
<p>This optimization is formulated as an integer programming problem:</p>
<p>Let <span class="math inline">\(S\)</span> be the set of all potential sites, and for each site <span class="math inline">\(i \in S\)</span>: - <span class="math inline">\(S_i\)</span> is a binary indicator variable where <span class="math inline">\(S_i = 1\)</span> if site <span class="math inline">\(i\)</span> is selected, and <span class="math inline">\(S_i = 0\)</span> otherwise - <span class="math inline">\(D_{i,j}\)</span> is a binary indicator where <span class="math inline">\(D_{i,j} = 1\)</span> if the distance between sites <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is greater than the minimum required distance (or if <span class="math inline">\(i = j\)</span>), and <span class="math inline">\(D_{i,j} = 0\)</span> otherwise. This reformulation removes the square-root constraint seen in section 7 and recasts the problem as a linear program.</p>
<p>The optimization problem is:</p>
<p><span class="math display">\[\text{maximize } \sum_{i \in S} S_i\]</span></p>
<p>Subject to: <span class="math display">\[S_i + S_j \leq D_{i,j} + 1 \quad \forall i,j \in S\]</span></p>
<p>This constraint ensures that if two sites <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are both selected (<span class="math inline">\(Z_i = Z_j = 1\)</span>), then they must be sufficiently far apart (<span class="math inline">\(D_{i,j} = 1\)</span>). The constraint cannot be satisfied if both are selected and are too close.</p>
</section>
<section id="stage-2-assign-sites-to-blocks-using-k-means-clustering" class="level4">
<h4 class="anchored" data-anchor-id="stage-2-assign-sites-to-blocks-using-k-means-clustering">Stage 2: Assign Sites to Blocks Using K-means Clustering</h4>
<p>Once we have selected the maximum number of eligible sites, we assign them to blocks to minimize within-block variance. For a design with exactly one treated unit per block, power is maximized when the within-block variance is minimized.</p>
<p>We use k-means clustering on the outcome variable to achieve this, where <span class="math inline">\(k\)</span> equals the number of desired blocks:</p>
<ol type="1">
<li>Initialize <span class="math inline">\(k\)</span> centroids randomly from the outcome values of selected sites</li>
<li>Assign each site to the nearest centroid based on the absolute difference in outcome values</li>
<li>Recalculate centroids as the mean of outcome values in each cluster</li>
<li>Repeat steps 2-3 until convergence</li>
</ol>
<p>For one-dimensional clustering (i.e., clustering on a single outcome variable), the k-means loss function is:</p>
<p><span class="math display">\[\sum_{k=1}^{K} \sum_{i \in C_k} (Y_i - \mu_k)^2\]</span></p>
<p>Where: - <span class="math inline">\(C_k\)</span> is the set of sites assigned to block <span class="math inline">\(k\)</span> - <span class="math inline">\(Y_i\)</span> is the outcome value for site <span class="math inline">\(i\)</span> - <span class="math inline">\(\mu_k\)</span> is the mean outcome value for block <span class="math inline">\(k\)</span></p>
<p>This loss function is directly related to minimizing the within-block variance, as the within-block variance for block <span class="math inline">\(k\)</span> is:</p>
<p><span class="math display">\[\sigma_k^2 = \frac{1}{n_k-1} \sum_{i \in C_k} (Y_i - \mu_k)^2\]</span></p>
<p>Therefore, minimizing the k-means loss function effectively minimizes the within-block variance, which maximizes power according to our variance formula in Section 4.</p>
<p>After k-means clustering, we ensure each block has at least two sites (one treated, one control) by reassigning sites from larger blocks to smaller ones if necessary, based on outcome value similarity.</p>
</section>
<section id="stage-3-calculate-power-based-on-block-assignment" class="level4">
<h4 class="anchored" data-anchor-id="stage-3-calculate-power-based-on-block-assignment">Stage 3: Calculate Power Based on Block Assignment</h4>
<p>With the blocks established, we can calculate the power of our design using the formula from Section 6:</p>
<p><span class="math display">\[\text{Power} = 1 - \beta = \Phi\left(\frac{|\delta|}{\sqrt{\widehat{\text{Var}}(\hat{\tau}_{(BK)})}} - z_{1-\alpha/2}\right)\]</span></p>
<p>Where the variance of the treatment effect estimator is:</p>
<p><span class="math display">\[\widehat{\text{Var}}(\hat{\tau}_{(BK)}) = \sum_{k=1}^{K} \frac{n_k^3}{n^2(n_k - 1)}\hat{\sigma}_k^2\]</span></p>
<p>And <span class="math inline">\(\hat{\sigma}_k^2\)</span> is estimated from the pre-treatment outcome data:</p>
<p><span class="math display">\[\hat{\sigma}_k^2 = \frac{1}{n_k-1} \sum_{i=1}^{n_k} (Y_{ik} - \bar{Y}_{k})^2\]</span></p>
<p>The treatment effect size <span class="math inline">\(\delta\)</span> can be specified either as a fixed value or as a percentage of the average outcome across selected sites.</p>
</section>
<section id="implementation-considerations" class="level4">
<h4 class="anchored" data-anchor-id="implementation-considerations">Implementation Considerations</h4>
<p>Key considerations for implementation include:</p>
<ol type="1">
<li><p><strong>Filtering criteria</strong>: We apply filtering criteria to sites before stage 1 to ensure all candidate sites meet minimum requirements.</p></li>
<li><p><strong>Minimum selected sites</strong>: We require at least twice the number of blocks to be selected (to have at least one control unit per block). If fewer sites are selected, an error is raised.</p></li>
<li><p><strong>Block balance</strong>: We enforce a minimum of two sites per block, which ensures we have at least one control unit per block.</p></li>
<li><p><strong>Distance calculation</strong>: Pairwise distances between sites are calculated using their geographic coordinates, typically in a projected coordinate system where Euclidean distance corresponds to meters.</p></li>
<li><p><strong>Significance level</strong>: A standard significance level of Î± = 0.05 is typically used, corresponding to a critical value of <span class="math inline">\(z_{1-\alpha/2} = 1.96\)</span> for a two-sided test.</p></li>
</ol>
<p>By following this three-stage approach, we maximize power by selecting the maximum number of sites subject to distance constraints and optimally assigning them to blocks to minimize within-block variance, while maintaining the ability to detect a specified treatment effect size with high probability.</p>
</section>
</section>
<section id="assumptions" class="level3">
<h3 class="anchored" data-anchor-id="assumptions">9 Assumptions</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 38%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Assumption</strong></th>
<th><strong>Role in Power Formula</strong></th>
<th><strong>Risk if Violated</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Normality of the estimator</strong></td>
<td>Justifies use of the standard normal distribution (<span class="math inline">\(\Phi\)</span>) for computing power.</td>
<td>Power estimates may be inaccurate, especially if the number of blocks is small or outcome distributions are skewed.</td>
</tr>
<tr class="even">
<td><strong>Accurate variance estimation</strong></td>
<td>Required to plug into the denominator of the standardized effect size (<span class="math inline">\(\delta / \sqrt{Var}\)</span>).</td>
<td>Under- or overestimation of variance leads to over- or underestimation of power.</td>
</tr>
<tr class="odd">
<td><strong>Independence within blocks</strong></td>
<td>Ensures that variance components add properly; needed for block-specific variance formulas.</td>
<td>Correlated outcomes (e.g., due to interference or spillovers) can underestimate variance and inflate power.</td>
</tr>
<tr class="even">
<td><strong>Homoskedasticity within blocks</strong></td>
<td>Assumes treated and control units within the same block have the same outcome variance.</td>
<td>If treatment changes variability, the variance formula for <span class="math inline">\(\hat{\tau}_k\)</span> is invalid.</td>
</tr>
<tr class="odd">
<td><strong>Constant treatment effect</strong></td>
<td>Assumes a fixed treatment effect <span class="math inline">\(\delta\)</span> for the power calculation.</td>
<td>If effects vary across units/blocks, power calculations may not reflect the true ability to detect effects.</td>
</tr>
<tr class="even">
<td><strong>Correct <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span></strong></td>
<td>Determines critical values (<span class="math inline">\(z_{1-\alpha/2}\)</span>, <span class="math inline">\(z_{1-\beta}\)</span>) used in the power formula.</td>
<td>Wrong values lead to incorrect inference thresholds (e.g., too lenient or too strict).</td>
</tr>
<tr class="odd">
<td><strong>No covariate adjustment</strong></td>
<td>Matches the unadjusted variance formula derived from the block-only design.</td>
<td>If covariates are used in analysis but not in the power calculation, power may be underestimated.</td>
</tr>
</tbody>
</table>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">10. Implementation</h3>
<p>For the results presented here, the parameters were:</p>
<ul>
<li>Outcome variable: Overdose calls within 3,000 meters</li>
<li><span class="math inline">\(D_{min}\)</span>: 6,000 meters</li>
<li>Filter variable: Overdose calls within 3,000 meters</li>
<li>Filter Threshold: Iterated over a minimum threshold starting at 0 and ending at 20 calls</li>
<li>Effect size: 15% of the selected site mean</li>
<li>Number of blocks: 4</li>
</ul>
</section>
<section id="findings" class="level3">
<h3 class="anchored" data-anchor-id="findings">11. Findings</h3>
<p>Figure 1 below depicts the power calculations for selected sites based on the threshold minimum.</p>
<p><img src="images\power_analysis_plot.png" alt="Figure 1" width="50%"></p>
<p><br></p>
<p>While there is an arrangement of sites with a power level greater than 80%, the analyses here represent an upper bound on the power calculations. This analysis is an upper bound on the power calculation because a number of key assumptions are likely violated. For instance, with only 4 blocks the normality of the estimator is unlikely to hold. Furthermore, the scenario where the power reached more than 80% had only 10 total sites selected. This means at most 3 sites per block were used to inform the estimate of the within-block variance.</p>
<p>Figure 2 below plots the number of sites selected on the x-axis, the average within-block variance on the y-axis, and a gradient and marker size value for the power with larger and redder markers indicating greater power.</p>
<p><img src="images\variance_nsites_power.png" alt="Figure 1" width="50%"></p>
<p><br></p>
<p>What is clear from figure 2 is that the arrangements with the highest power are driven almost entirely by reductions in the within-block variance. This combined with the low sample sizes is concerning, since it could indicate our algorithm is overfitting. The low block sample sizes mean our process for selecting blocks after site selection is likely underestimating the true within-block variance.</p>
<p>That being said, the sites that are selected do possess several desirable qualities. They are geographically distant from one another (see figure 3), have higher call volumes than the average site, and have low within-block variance.</p>
<p><img src="images\best_power_sites.png" alt="Figure 1" width="50%"></p>
</section>
</div>
</div>
</div>
</section>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next Steps</h2>
<ul>
<li>Containerize with Docker and deploy via AWS</li>
<li>Consider alternative RCT designs. If applicable, create <a href="https://link.springer.com/article/10.3758/s13428-021-01546-0">synthetic</a> data and run power calculations.</li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>National Academies of Sciences, Engineering, and Medicine. (2018). Medication-Assisted Treatment for Opioid Use Disorder.</p>
<p>Pashley, N. E., &amp; Miratrix, L. W. (2021). Insights on Variance Estimation for Blocked and Matched Pairs Designs. <em>Journal of Educational and Behavioral Statistics</em>, 46(3), 271-296.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/gratzt\.github\.io\/Portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>